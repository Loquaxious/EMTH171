% emth171 case study 2
% jackson crawford
% modelling of the water level in hydroelectric dams as a function of power
% consumption in new zealand

clear
clc

% enables verbose logging for calculating loops, showing values at each
% step. set to 1 for verbose values, set to 0 for less clutter in command
% window
enableVerboseLogging = 0;

% allows quickly changing the global iteration value for wind and geo if
% they are able to both be the same, as it doesn't really matter:
windIterVal = 5;
geoIterVal = 5;

if enableVerboseLogging
    fprintf('Verbose logging enabled \n')
else
    fprintf('Verbose logging disabled \n')
end


% variables
p = 998;
g = 9.81;
k = 1.55;
l = 300;
aNI = 620*1000^2;
aSI = 350*1000^2;
pGeo = 1525;
pNIdem = @(t) (4065+1.4e6*normpdf(t, 5000, 1000));
pSIdem = 1940;
northIslandWind = 2065;
southIslandWind = 2065;
SIMinHeight = 402;
NIMinHeight = 356.25;

% arrays, initial values for ODE's

tArray = 1:8760;
vNISpillArray = zeros(1,8761);
vSISpillArray = zeros(1,8761);
hNIArray = zeros(1,8761);
hSIArray = zeros(1,8761);
hNIArray(1) = 357;
hSIArray(1) = 406;

% functions
fNIin = @(t) 345 + 73*sin((2*pi*(t-3624))/8760);
fSIin = @(t) 593 - 183*sin((2*pi*(t-2320))/8760);

% pHydroSI = @(fGen) (0.9*fGen*p*g*(h))/10^6;

SIHydroArray = 0;
NIHydroArray = 0;

SIMin = 399;

southIslandWindArray = southIslandWind;
SIMinArray = 399;

fprintf('Optimising wind capacity with a step of %d, please wait \n', windIterVal)

disp(' ')

while SIMin < SIMinHeight
southIslandWind = southIslandWind + windIterVal;
northIslandWind = northIslandWind + windIterVal;

if enableVerboseLogging
disp('*****************************************')
fprintf('north island wind = %.2f MW \n', northIslandWind)
fprintf('south island wind = %.2f MW \n', southIslandWind)
disp('*****************************************')
end

SIMinArray = [SIMinArray, SIMin];
southIslandWindArray = [southIslandWindArray, southIslandWind];

% arrays, initial values for ODE's

tArray = 1:8760;
vNISpillArray = zeros(1,8761);
vSISpillArray = zeros(1,8761);
hNIArray = zeros(1,8761);
hSIArray = zeros(1,8761);
hNIArray(1) = 357;
hSIArray(1) = 406;

for n = tArray
t = tArray(n);

t = tArray(n);

% calculate current power demand of north and south islands, MW
currentNorthIslandDemand = pNIdem(t);
currentSouthIslandDemand = pSIdem;

% calculate current flow rate into each reservoir, m^3s^-1
inflowNorthIsland = fNIin(t);
inflowSouthIsland = fSIin(t);

% flow out of the north island dam used for generating power, m^3s^-1
genFlowNorthIsland = inflowNorthIsland;

% power generated by north island hydro as a function of the height, MW
hydroGenNorthIsland = (0.9*genFlowNorthIsland*p*g*(hNIArray(n)-80))/10^6;

% wind capacity factor, constant over the two islands based on time of
% year, general indicator of wind farm efficiency
windCapacityFactor = 0.41 + 0.12*sin((2*pi*(t-5660))/8760);

% total generation of power out of the north island, MW
northIslandTotalGen = pGeo + hydroGenNorthIsland + (northIslandWind * windCapacityFactor);

% total power demand of the north island, based on time of year, MW
northIslandDemand = 4065+1.4e6*normpdf(t, 5000, 1000);

% north island power deficit, e.g power needing to be routed north from
% south island production through HVDC cable, MW
northIslandDeficit = (northIslandDemand - northIslandTotalGen);

% power requirement from the south island, taken from power demand of south
% island + power required to be sent to north island, - power generated
% from wind farms in the south island based on the time of year, MW
southIslandHydro = pSIdem + northIslandDeficit - (southIslandWind * windCapacityFactor);

% water flow required through south island hydro to produce required power,
% m^3s^-1
genFlowSouthIsland = ((10^6*southIslandHydro)/(0.9*p*g*(hSIArray(n))));

% set initial spill rates for both dams, if the height of the water is not
% above the height of the dam, there is no spill, m^3s^-1

if hNIArray(n) > 357.25
    fSpillNI = k*l*(hNIArray(n)-357.25)^1.5;
else
    fSpillNI = 0;
end

if hSIArray(n) > 410
    fSpillSI = k*l*(hSIArray(n)-410)^1.5;
else
    fSpillSI = 0;
end

% rate of spill in m^3s^-1, multiplied by 3600 to attain m^3h^-1
dvdtNISpill = fSpillNI;
dvdtSISpill = fSpillSI;

% rate of height change in each lake derived from net water flow, ms^-1
dhdtNI = ((inflowNorthIsland - genFlowNorthIsland - fSpillNI)/aNI);
dhdtSI = ((inflowSouthIsland - genFlowSouthIsland - fSpillSI)/aSI);

% next lake height in north island for euler's method, m
hNINext = hNIArray(n) + dhdtNI*3600;

% append next height to array of heights for plot
hNIArray(n+1) = hNINext;

% next lake height in south island for euler's method, m
hSINext = hSIArray(n) + dhdtSI*3600;

% append next height to array of heights for plot
hSIArray(n+1) = hSINext;

% append volume spilt to arrays of volume previously spilt
vNISpillArray(n+1) = (vNISpillArray(n) + dvdtNISpill*3600);
vSISpillArray(n+1) = (vSISpillArray(n) + dvdtSISpill*3600);
end

% print minimum lake levels to check they are not below the limit
SIMin = min(hSIArray);
NImin = min(hNIArray);

if enableVerboseLogging
   
if SIMin < SIMinHeight
    fprintf('south island lake has dropped below minimum level of 402m \n')
    fprintf('south island minimum lake level = %.2fm \n' , SIMin)
    fprintf('this is %.2fm below required level\n', SIMinHeight-SIMin)
    disp('*****************************************')
    fprintf('\n')
    fprintf('iterating\n')
    fprintf('\n')
 
end

end

end

windFinal = northIslandWind;

% fix tArray for plots
tArray = [tArray, 8761];

northIslandWind = 2065;
southIslandWind = 2065;

SIMin = 399;
SIMinArray = SIMin;

fprintf('Wind optimised \n')
fprintf('Optimising geothermal capacity with a step of %d, please wait \n', geoIterVal)

disp(' ')

while SIMin < SIMinHeight
pGeo = pGeo + geoIterVal;

if enableVerboseLogging
disp('*****************************************')
fprintf('geothermal power = %.2fMW \n', pGeo)
disp('*****************************************')
end

northIslandWind = 2065;
southIslandWind = 2065;

SIMinArray = [SIMinArray, SIMin];
southIslandWindArray = [southIslandWindArray, southIslandWind];

% arrays, initial values for ODE's

tArray = 1:8760;
vNISpillArray = zeros(1,8761);
vSISpillArray = zeros(1,8761);
hNIArray = zeros(1,8761);
hSIArray = zeros(1,8761);
hNIArray(1) = 357;
hSIArray(1) = 406;

for n = tArray
t = tArray(n);

t = tArray(n);

% calculate current power demand of north and south islands, MW
currentNorthIslandDemand = pNIdem(t);
currentSouthIslandDemand = pSIdem;

% calculate current flow rate into each reservoir, m^3s^-1
inflowNorthIsland = fNIin(t);
inflowSouthIsland = fSIin(t);

% flow out of the north island dam used for generating power, m^3s^-1
genFlowNorthIsland = inflowNorthIsland;

% power generated by north island hydro as a function of the height, MW
hydroGenNorthIsland = (0.9*genFlowNorthIsland*p*g*(hNIArray(n)-80))/10^6;

% wind capacity factor, constant over the two islands based on time of
% year, general indicator of wind farm efficiency
windCapacityFactor = 0.41 + 0.12*sin((2*pi*(t-5660))/8760);

% total generation of power out of the north island, MW
northIslandTotalGen = pGeo + hydroGenNorthIsland + (northIslandWind * windCapacityFactor);

% total power demand of the north island, based on time of year, MW
northIslandDemand = 4065+1.4e6*normpdf(t, 5000, 1000);

% north island power deficit, e.g power needing to be routed north from
% south island production through HVDC cable, MW
northIslandDeficit = (northIslandDemand - northIslandTotalGen);

% power requirement from the south island, taken from power demand of south
% island + power required to be sent to north island, - power generated
% from wind farms in the south island based on the time of year, MW
southIslandHydro = pSIdem + northIslandDeficit - (southIslandWind * windCapacityFactor);

% water flow required through south island hydro to produce required power,
% m^3s^-2
genFlowSouthIsland = ((10^6*southIslandHydro)/(0.9*p*g*(hSIArray(n))));

% set initial spill rates for both dams, if the height of the water is not
% above the height of the dam, there is no spill, m^3s^-1

if hNIArray(n) > 357.25
    fSpillNI = k*l*(hNIArray(n)-357.25)^1.5;
else
    fSpillNI = 0;
end

if hSIArray(n) > 410
    fSpillSI = k*l*(hSIArray(n)-410)^1.5;
else
    fSpillSI = 0;
end

% rate of spill in m^3s^-1, multiplied by 3600 to attain m^3h^-1
dvdtNISpill = fSpillNI;
dvdtSISpill = fSpillSI;

% rate of height change in each lake derived from net water flow, ms^-1
dhdtNI = ((inflowNorthIsland - genFlowNorthIsland - fSpillNI)/aNI);
dhdtSI = ((inflowSouthIsland - genFlowSouthIsland - fSpillSI)/aSI);

% next lake height in north island for euler's method, m
hNINext = hNIArray(n) + dhdtNI*3600;

% append next height to array of heights for plot
hNIArray(n+1) = hNINext;

% next lake height in south island for euler's method, m
hSINext = hSIArray(n) + dhdtSI*3600;

% append next height to array of heights for plot
hSIArray(n+1) = hSINext;

% append volume spilt to arrays of volume previously spilt
vNISpillArray(n+1) = (vNISpillArray(n) + dvdtNISpill*3600);
vSISpillArray(n+1) = (vSISpillArray(n) + dvdtSISpill*3600);

% print minimum lake levels to check they are not below the limit
SIMin = min(hSIArray);
NImin = min(hNIArray);
if enableVerboseLogging
   
if SIMin < SIMinHeight
    fprintf('south island lake has dropped below minimum level of 402m \n')
    fprintf('south island minimum lake level = %.2fm \n' , SIMin)
    fprintf('this is %.2fm below required level\n', SIMinHeight-SIMin)
    disp('*****************************************')
    fprintf('\n')
    fprintf('iterating\n')
    fprintf('\n')
end

end

end

end

disp('*****************************************')
disp('loops completed, displaying final results')
disp('*****************************************')

fprintf('final wind power requirement = %.2f \n', windFinal)
fprintf('final geothermal power requirement = %.2f MW \n', pGeo)

windUpgradeCost = (northIslandWind + southIslandWind - 580)*3000*1000;
geothermalUpgradeCost = (pGeo - 960)*4500*1000;
fprintf('geothermal upgrade cost = $%.2f Billion \n', geothermalUpgradeCost/10^9)
fprintf('wind upgrade cost = $%.2f Billion \n', windUpgradeCost/10^9)